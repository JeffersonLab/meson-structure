#!/usr/bin/env python3
"""
# Lambda Decay Visualizer

This script analyzes Lambda decay data from CSV files generated by the Lambda decay analyzer
and creates histograms showing the spatial distribution of decay products.

The script produces:
1. Individual 1D histograms of the z-coordinate of endpoints for Lambda, proton, and π- particles
2. Individual 2D histograms showing z vs y coordinates of endpoints for each particle type

Usage:
    python lambda_decay_visualizer.py -i INPUT_FILE.csv -o OUTPUT_FOLDER
"""

import argparse
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LogNorm


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Visualize Lambda decay data with histograms.")
    parser.add_argument("-i", "--input-file", required=True,
                        help="Path to CSV file with Lambda decay data.")
    parser.add_argument("-o", "--output-folder", default="lambda_plots",
                        help="Output folder for plots (default: 'lambda_plots').")
    parser.add_argument("-e", "--beam-energy", default=None,
                        help="Beam energy for plot labeling (e.g., '5x41 GeV')")
    return parser.parse_args()


def ensure_output_folder(folder):
    """Create output folder if it doesn't exist."""
    if not os.path.exists(folder):
        os.makedirs(folder)
        print(f"Created output folder: {folder}")


def load_data(file_path):
    """Load Lambda decay data from CSV file."""
    print(f"Loading data from {file_path}")
    df = pd.read_csv(file_path)
    print(f"Loaded {len(df)} Lambda decay events")
    return df


def analyze_lambda_decays(df):
    """Analyze Lambda decay Z values to check for consistency."""
    print("\n=== Lambda Decay Z Analysis ===")

    # Convert to meters for readability
    lam_z = df['lam_endpoint_z'] / 1000

    # Basic statistics
    print(f"Lambda Z endpoint statistics (meters):")
    print(f"  Mean: {lam_z.mean():.3f}")
    print(f"  Median: {lam_z.median():.3f}")
    print(f"  Min: {lam_z.min():.3f}")
    print(f"  Max: {lam_z.max():.3f}")
    print(f"  Standard deviation: {lam_z.std():.3f}")

    # Check for unusual patterns
    print("\nDistribution check:")
    print(f"  25th percentile: {lam_z.quantile(0.25):.3f}")
    print(f"  75th percentile: {lam_z.quantile(0.75):.3f}")
    print(f"  Interquartile range: {(lam_z.quantile(0.75) - lam_z.quantile(0.25)):.3f}")

    print("\nWARNING: If Lambda Z decay values are unexpectedly similar across different beam energies,")
    print("         check your data processing steps to ensure correct physics is being captured.")
    print("         Lambda decay length should generally increase with beam energy.")
    print("=" * 30)


def create_1d_histograms(df, output_folder, beam_energy=None):
    """Create separate 1D histograms of endpoint z-coordinates."""
    print("Creating individual 1D histograms of endpoint z-coordinates...")

    # Define z-range for all histograms (-5 to 40 meters as requested)
    z_bins = np.linspace(-5, 40, 100)

    # Define particles to plot
    particles = [
        ('lam', 'Lambda', 'blue'),
        ('prot', 'Proton', 'green'),
        ('piminus', 'π⁻', 'red')
    ]

    energy_str = f" ({beam_energy})" if beam_energy else ""

    for prefix, name, color in particles:
        plt.figure(figsize=(10, 6))

        # Get z coordinate data and convert to meters
        z_data = df[f'{prefix}_endpoint_z'] / 1000

        # Create histogram
        plt.hist(z_data, bins=z_bins, alpha=0.7, color=color)
        plt.title(f'{name} Endpoint Z Distribution{energy_str}', fontsize=14)
        plt.xlabel('Z-coordinate (meters)', fontsize=12)
        plt.ylabel('Count', fontsize=12)
        plt.grid(True, alpha=0.3)

        # Add statistical information to the plot
        stats_text = (
            f"Mean: {z_data.mean():.2f} m\n"
            f"Median: {z_data.median():.2f} m\n"
            f"Std Dev: {z_data.std():.2f} m"
        )

        # Position the text in the upper right corner
        plt.annotate(stats_text, xy=(0.95, 0.95), xycoords='axes fraction',
                     fontsize=10, ha='right', va='top',
                     bbox=dict(boxstyle='round,pad=0.5', fc='white', alpha=0.7))

        # Save the plot
        output_path = os.path.join(output_folder, f"1d_{prefix}_endpoint_z.png")
        plt.tight_layout()
        plt.savefig(output_path, dpi=300)
        print(f"Saved 1D histogram for {name} to {output_path}")
        plt.close()


def create_2d_histograms(df, output_folder, beam_energy=None):
    """Create individual 2D histograms of endpoint z vs y coordinates."""
    print("Creating 2D histograms of endpoint z vs y coordinates...")

    # Define particles to plot
    particles = [
        ('lam', 'Lambda', 'Blues'),
        ('prot', 'Proton', 'Greens'),
        ('piminus', 'π⁻', 'Reds')
    ]

    # Define coordinate ranges (convert to meters)
    z_range = [-5, 40]  # meters
    y_range = [-1, 1]  # meters

    energy_str = f" ({beam_energy})" if beam_energy else ""

    for prefix, name, cmap in particles:
        plt.figure(figsize=(12, 8))

        # Get coordinate data and convert to meters
        z_data = df[f'{prefix}_endpoint_z'] / 1000
        y_data = df[f'{prefix}_endpoint_y'] / 1000

        # Filter outliers
        mask = (z_data >= z_range[0]) & (z_data <= z_range[1]) & (y_data >= y_range[0]) & (y_data <= y_range[1])

        # Create 2D histogram
        h = plt.hist2d(
            z_data[mask],
            y_data[mask],
            bins=[100, 100],
            range=[z_range, y_range],
            cmap=cmap,
            norm=LogNorm()
        )

        plt.title(f'{name} Endpoint (Z vs Y){energy_str}', fontsize=16)
        plt.xlabel('Z-coordinate (meters)', fontsize=14)
        plt.ylabel('Y-coordinate (meters)', fontsize=14)
        plt.colorbar(label='Count')
        plt.grid(alpha=0.3)

        # Save the plot
        output_path = os.path.join(output_folder, f"2d_{prefix}_endpoint_zy.png")
        plt.tight_layout()
        plt.savefig(output_path, dpi=300)
        print(f"Saved 2D histogram for {name} to {output_path}")
        plt.close()

    # Create higher resolution individual plots with adjustable range
    create_detailed_2d_plots(df, output_folder, beam_energy)


def create_detailed_2d_plots(df, output_folder, beam_energy=None):
    """Create detailed 2D plots with higher resolution."""
    particles = [
        ('lam', 'Lambda', 'Blues'),
        ('prot', 'Proton', 'Greens'),
        ('piminus', 'π⁻', 'Reds')
    ]

    # Adjust these ranges for better visibility
    z_range = [-5, 40]  # meters
    y_range = [-2, 2]  # meters

    energy_str = f" ({beam_energy})" if beam_energy else ""

    for prefix, name, cmap in particles:
        plt.figure(figsize=(12, 10))

        z_data = df[f'{prefix}_endpoint_z'] / 1000
        y_data = df[f'{prefix}_endpoint_y'] / 1000

        # Filter outliers
        mask = (z_data >= z_range[0]) & (z_data <= z_range[1]) & (y_data >= y_range[0]) & (y_data <= y_range[1])

        h = plt.hist2d(
            z_data[mask],
            y_data[mask],
            bins=[150, 150],
            range=[z_range, y_range],
            cmap=cmap,
            norm=LogNorm()
        )

        plt.title(f'{name} Endpoint (Z vs Y) - Detailed{energy_str}', fontsize=16)
        plt.xlabel('Z-coordinate (meters)', fontsize=14)
        plt.ylabel('Y-coordinate (meters)', fontsize=14)
        plt.colorbar(label='Count')
        plt.grid(alpha=0.3)

        # Add statistical information
        stats_text = (
            f"Z mean: {z_data[mask].mean():.2f} m\n"
            f"Y mean: {y_data[mask].mean():.2f} m\n"
            f"Z std: {z_data[mask].std():.2f} m\n"
            f"Y std: {y_data[mask].std():.2f} m"
        )

        plt.annotate(stats_text, xy=(0.95, 0.05), xycoords='axes fraction',
                     fontsize=10, ha='right', va='bottom',
                     bbox=dict(boxstyle='round,pad=0.5', fc='white', alpha=0.7))

        output_path = os.path.join(output_folder, f"2d_{prefix}_endpoint_zy_detailed.png")
        plt.tight_layout()
        plt.savefig(output_path, dpi=300)
        print(f"Saved detailed 2D plot for {name} to {output_path}")
        plt.close()


def create_comparison_plot(df, output_folder, beam_energy=None):
    """Create a comparison plot showing all three particle Z distributions together."""
    print("Creating comparison plot of Z endpoint distributions...")

    plt.figure(figsize=(12, 8))

    # Define z-range
    z_bins = np.linspace(-5, 40, 100)

    # Plot each particle type with different colors and transparency
    plt.hist(df['lam_endpoint_z'] / 1000, bins=z_bins, alpha=0.5, color='blue', label='Lambda')
    plt.hist(df['prot_endpoint_z'] / 1000, bins=z_bins, alpha=0.5, color='green', label='Proton')
    plt.hist(df['piminus_endpoint_z'] / 1000, bins=z_bins, alpha=0.5, color='red', label='π⁻')

    energy_str = f" ({beam_energy})" if beam_energy else ""
    plt.title(f'Comparison of Endpoint Z Distributions{energy_str}', fontsize=16)
    plt.xlabel('Z-coordinate (meters)', fontsize=14)
    plt.ylabel('Count', fontsize=14)
    plt.grid(True, alpha=0.3)
    plt.legend(fontsize=12)

    # Save the plot
    output_path = os.path.join(output_folder, "comparison_z_distributions.png")
    plt.tight_layout()
    plt.savefig(output_path, dpi=300)
    print(f"Saved comparison plot to {output_path}")
    plt.close()


def main():
    """Main function."""
    args = parse_args()

    # Ensure output folder exists
    ensure_output_folder(args.output_folder)

    # Load data
    df = load_data(args.input_file)

    # Analyze Lambda decay Z values
    analyze_lambda_decays(df)

    # Create individual histograms
    create_1d_histograms(df, args.output_folder, args.beam_energy)
    create_2d_histograms(df, args.output_folder, args.beam_energy)

    # Create comparison plot with all particle types
    create_comparison_plot(df, args.output_folder, args.beam_energy)

    print("Analysis complete!")


if __name__ == "__main__":
    main()